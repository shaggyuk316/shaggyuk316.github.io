// 3D setup
const scene = new THREE.Scene(); // 'const' and 'scene' are blue (keyword and variable)
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 600, 0.1, 1000); // 'const', 'camera' blue
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('combinedCanvas') }); // 'const', 'renderer' blue
renderer.setSize(window.innerWidth, 600);
scene.background = new THREE.Color(0xffffff);
camera.position.set(0, 0, 20);
camera.lookAt(0, 0, 0);
const controls = new THREE.OrbitControls(camera, renderer.domElement); // 'const', 'controls' blue

let binaryCubes = [], quantsparkFlares = [], chaosbloomWeb; // 'let', 'binaryCubes', etc. blue

function updateAll() { // 'function', 'updateAll' blue
    scene.children = [];
    binaryCubes = [];
    quantsparkFlares = [];
    chaosbloomWeb = null;

    // Binary: Cubes
    const binarySize = parseInt(document.getElementById('binarySize').value) || 5; // 'const', 'binarySize' blue
    const binaryColor = document.getElementById('binaryColor').value || '#0000FF'; // 'const', 'binaryColor' blue
    const binaryDensityToggle = document.getElementById('binaryDensityToggle').checked; // 'const', 'binaryDensityToggle' blue
    const binaryDensity = binaryDensityToggle ? parseFloat(document.getElementById('binaryDensity').value) || 0.2 : 0.2; // 'const', 'binaryDensity' blue
    const binarySoundToggle = document.getElementById('binarySoundToggle').checked; // 'const', 'binarySoundToggle' blue
    const binarySound = binarySoundToggle ? parseFloat(document.getElementById('binarySound').value) || 0.5 : 0; // 'const', 'binarySound' blue
    const binaryVibrationToggle = document.getElementById('binaryVibrationToggle').checked; // 'const', 'binaryVibrationToggle' blue
    const binaryVibration = binaryVibrationToggle ? parseFloat(document.getElementById('binaryVibration').value) || 0.5 : 0; // 'const', 'binaryVibration' blue
    const binaryPositiveChargeToggle = document.getElementById('binaryPositiveChargeToggle').checked; // 'const', 'binaryPositiveChargeToggle' blue
    const binaryPositiveCharge = binaryPositiveChargeToggle ? parseFloat(document.getElementById('binaryPositiveCharge').value) || 0.5 : 0; // 'const', 'binaryPositiveCharge' blue
    const binaryNegativeChargeToggle = document.getElementById('binaryNegativeChargeToggle').checked; // 'const', 'binaryNegativeChargeToggle' blue
    const binaryNegativeCharge = binaryNegativeChargeToggle ? parseFloat(document.getElementById('binaryNegativeCharge').value) || 0.5 : 0; // 'const', 'binaryNegativeCharge' blue
    const binaryNetCharge = binaryPositiveCharge - binaryNegativeCharge; // 'const', 'binaryNetCharge' blue
    const binaryGeo = new THREE.BoxGeometry(1 + binaryDensity, 1 + binaryDensity, 1 + binaryDensity); // 'const', 'binaryGeo' blue
    const binaryMat = new THREE.MeshBasicMaterial({ color: binaryColor }); // 'const', 'binaryMat' blue
    for (let i = 0; i < binarySize; i++) { // 'for', 'let', 'i' blue
        const cube = new THREE.Mesh(binaryGeo, binaryMat); // 'const', 'cube' blue
        cube.position.set(i * 2 - (binarySize - 1), -5, 0);
        cube.sound = binarySound;
        cube.vibration = binaryVibration;
        cube.charge = binaryNetCharge;
        binaryCubes.push(cube);
        scene.add(cube);
    }

    // QuantSpark: Flares
    const quantsparkCount = parseInt(document.getElementById('quantsparkCount').value) || 10; // 'const', 'quantsparkCount' blue
    const quantsparkSolidColor = document.getElementById('quantsparkSolidColor').value || '#4B0082'; // 'const', 'quantsparkSolidColor' blue
    const quantsparkGasColor = document.getElementById('quantsparkGasColor').value || '#FF0000'; // 'const', 'quantsparkGasColor' blue
    const quantsparkMagneticToggle = document.getElementById('quantsparkMagneticToggle').checked; // 'const', 'quantsparkMagneticToggle' blue
    const quantsparkMagnetic = quantsparkMagneticToggle ? parseFloat(document.getElementById('quantsparkMagnetic').value) || 0.1 : 0; // 'const', 'quantsparkMagnetic' blue
    const quantsparkDensityToggle = document.getElementById('quantsparkDensityToggle').checked; // 'const', 'quantsparkDensityToggle' blue
    const quantsparkDensity = quantsparkDensityToggle ? parseFloat(document.getElementById('quantsparkDensity').value) || 0.2 : 0.2; // 'const', 'quantsparkDensity' blue
    const quantsparkSoundToggle = document.getElementById('quantsparkSoundToggle').checked; // 'const', 'quantsparkSoundToggle' blue
    const quantsparkSound = quantsparkSoundToggle ? parseFloat(document.getElementById('quantsparkSound').value) || 0.5 : 0; // 'const', 'quantsparkSound' blue
    const quantsparkVibrationToggle = document.getElementById('quantsparkVibrationToggle').checked; // 'const', 'quantsparkVibrationToggle' blue
    const quantsparkVibration = quantsparkVibrationToggle ? parseFloat(document.getElementById('quantsparkVibration').value) || 0.5 : 0; // 'const', 'quantsparkVibration' blue
    const quantsparkPositiveChargeToggle = document.getElementById('quantsparkPositiveChargeToggle').checked; // 'const', 'quantsparkPositiveChargeToggle' blue
    const quantsparkPositiveCharge = quantsparkPositiveChargeToggle ? parseFloat(document.getElementById('quantsparkPositiveCharge').value) || 0.5 : 0; // 'const', 'quantsparkPositiveCharge' blue
    const quantsparkNegativeChargeToggle = document.getElementById('quantsparkNegativeChargeToggle').checked; // 'const', 'quantsparkNegativeChargeToggle' blue
    const quantsparkNegativeCharge = quantsparkNegativeChargeToggle ? parseFloat(document.getElementById('quantsparkNegativeCharge').value) || 0.5 : 0; // 'const', 'quantsparkNegativeCharge' blue
    const quantsparkNetCharge = quantsparkPositiveCharge - quantsparkNegativeCharge; // 'const', 'quantsparkNetCharge' blue
    const quantsparkGeo = new THREE.SphereGeometry(0.5 + quantsparkDensity, 16, 16); // 'const', 'quantsparkGeo' blue
    for (let i = 0; i < quantsparkCount; i++) { // 'for', 'let', 'i' blue
        const solid = new THREE.Mesh(quantsparkGeo, new THREE.MeshBasicMaterial({ color: quantsparkSolidColor })); // 'const', 'solid' blue
        const gas = new THREE.Mesh(quantsparkGeo, new THREE.MeshBasicMaterial({ color: quantsparkGasColor })); // 'const', 'gas' blue
        solid.position.set(Math.random() * 10 - 5, 0, Math.random() * 10 - 5);
        gas.position.set(Math.random() * 10 - 5, 0, Math.random() * 10 - 5);
        solid.velocity = new THREE.Vector3((Math.random() - 0.5) * quantsparkMagnetic, (Math.random() - 0.5) * quantsparkMagnetic, (Math.random() - 0.5) * quantsparkMagnetic);
        gas.velocity = new THREE.Vector3((Math.random() - 0.5) * quantsparkMagnetic, (Math.random() - 0.5) * quantsparkMagnetic, (Math.random() - 0.5) * quantsparkMagnetic);
        solid.sound = quantsparkSound;
        gas.sound = quantsparkSound;
        solid.vibration = quantsparkVibration;
        gas.vibration = quantsparkVibration;
        solid.charge = quantsparkNetCharge;
        gas.charge = quantsparkNetCharge;
        quantsparkFlares.push({ solid, gas });
        scene.add(solid);
        scene.add(gas);
    }

    // ChaosBloom: Points
    const chaosbloomPoints = parseInt(document.getElementById('chaosbloomPoints').value) || 300; // 'const', 'chaosbloomPoints' blue
    const chaosbloomColor1 = document.getElementById('chaosbloomColor1').value || '#0000FF'; // 'const', 'chaosbloomColor1' blue
    const chaosbloomColor2 = document.getElementById('chaosbloomColor2').value || '#FF0000'; // 'const', 'chaosbloomColor2' blue
    const chaosbloomGravityToggle = document.getElementById('chaosbloomGravityToggle').checked; // 'const', 'chaosbloomGravityToggle' blue
    const chaosbloomGravity = chaosbloomGravityToggle ? parseFloat(document.getElementById('chaosbloomGravity').value) || 0.01 : 0; // 'const', 'chaosbloomGravity' blue
    const chaosbloomDensityToggle = document.getElementById('chaosbloomDensityToggle').checked; // 'const', 'chaosbloomDensityToggle' blue
    const chaosbloomDensity = chaosbloomDensityToggle ? parseFloat(document.getElementById('chaosbloomDensity').value) || 0.2 : 0.2; // 'const', 'chaosbloomDensity' blue
    const chaosbloomSoundToggle = document.getElementById('chaosbloomSoundToggle').checked; // 'const', 'chaosbloomSoundToggle' blue
    const chaosbloomSound = chaosbloomSoundToggle ? parseFloat(document.getElementById('chaosbloomSound').value) || 0.5 : 0; // 'const', 'chaosbloomSound' blue
    const chaosbloomVibrationToggle = document.getElementById('chaosbloomVibrationToggle').checked; // 'const', 'chaosbloomVibrationToggle' blue
    const chaosbloomVibration = chaosbloomVibrationToggle ? parseFloat(document.getElementById('chaosbloomVibration').value) || 0.5 : 0; // 'const', 'chaosbloomVibration' blue
    const chaosbloomPositiveChargeToggle = document.getElementById('chaosbloomPositiveChargeToggle').checked; // 'const', 'chaosbloomPositiveChargeToggle' blue
    const chaosbloomPositiveCharge = chaosbloomPositiveChargeToggle ? parseFloat(document.getElementById('chaosbloomPositiveCharge').value) || 0.5 : 0; // 'const', 'chaosbloomPositiveCharge' blue
    const chaosbloomNegativeChargeToggle = document.getElementById('chaosbloomNegativeChargeToggle').checked; // 'const', 'chaosbloomNegativeChargeToggle' blue
    const chaosbloomNegativeCharge = chaosbloomNegativeChargeToggle ? parseFloat(document.getElementById('chaosbloomNegativeCharge').value) || 0.5 : 0; // 'const', 'chaosbloomNegativeCharge' blue
    const chaosbloomNetCharge = chaosbloomPositiveCharge - chaosbloomNegativeCharge; // 'const', 'chaosbloomNetCharge' blue
    const chaosbloomGeo = new THREE.BufferGeometry(); // 'const', 'chaosbloomGeo' blue
    const vertices = []; // 'const', 'vertices' blue
    const colors = []; // 'const', 'colors' blue
    for (let i = 0; i < chaosbloomPoints; i++) { // 'for', 'let', 'i' blue
        vertices.push(Math.random() * 10 - 5, Math.random() * 10 + 5, Math.random() * 10 - 5);
        const color = Math.random() < 0.5 ? new THREE.Color(chaosbloomColor1) : new THREE.Color(chaosbloomColor2); // 'const', 'color' blue
        colors.push(color.r, color.g, color.b);
    }
    chaosbloomGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    chaosbloomGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const chaosbloomMat = new THREE.PointsMaterial({ size: 0.1 + chaosbloomDensity, vertexColors: true }); // 'const', 'chaosbloomMat' blue
    chaosbloomWeb = new THREE.Points(chaosbloomGeo, chaosbloomMat); // 'chaosbloomWeb' blue (global var)
    chaosbloomWeb.sound = chaosbloomSound;
    chaosbloomWeb.vibration = chaosbloomVibration;
    chaosbloomWeb.charge = chaosbloomNetCharge;
    chaosbloomWeb.gravity = chaosbloomGravity;
    scene.add(chaosbloomWeb);

    console.log('Scene objects:', scene.children.length);
}

updateAll();

function animate() { // 'function', 'animate' blue
    requestAnimationFrame(animate);
    binaryCubes.forEach(cube => { // 'forEach' blue
        cube.scale.set(1 + cube.sound * Math.sin(Date.now() * 0.001), 1, 1);
        cube.position.y += cube.vibration * Math.sin(Date.now() * 0.002) * 0.1;
        cube.rotation.z += cube.charge * 0.01;
        if (cube.position.y > -2) cube.position.y = -8;
    });
    quantsparkFlares.forEach(flare => { // 'forEach' blue
        flare.solid.rotation.x += flare.sound * 0.05;
        flare.solid.rotation.y += flare.sound * 0.05;
        flare.gas.rotation.x += flare.sound * 0.05;
        flare.gas.rotation.y += flare.sound * 0.05;
        flare.solid.position.add(flare.solid.velocity);
        flare.gas.position.add(flare.gas.velocity);
        flare.solid.position.clamp(new THREE.Vector3(-10, -2, -10), new THREE.Vector3(10, 2, 10));
        flare.gas.position.clamp(new THREE.Vector3(-10, -2, -10), new THREE.Vector3(10, 2, 10));
        flare.solid.scale.set(1 + flare.vibration * Math.sin(Date.now() * 0.005), 1, 1);
        flare.gas.scale.set(1 + flare.vibration * Math.sin(Date.now() * 0.007), 1, 1);
    });
    if (chaosbloomWeb) {
        const positions = chaosbloomWeb.geometry.attributes.position.array; // 'const', 'positions' blue
        for (let i = 0; i < positions.length; i += 3) { // 'for', 'let', 'i' blue
            positions[i + 1] += chaosbloomWeb.sound * Math.sin(Date.now() * 0.001) * 0.05;
            positions[i + 1] -= chaosbloomWeb.gravity * 0.01;
            if (positions[i + 1] < 2) positions[i + 1] = 8;
            positions[i] += chaosbloomWeb.vibration * Math.sin(Date.now() * 0.002) * 0.05;
            positions[i + 2] += chaosbloomWeb.charge * Math.cos(Date.now() * 0.003) * 0.05;
        }
        chaosbloomWeb.geometry.attributes.position.needsUpdate = true;
        chaosbloomWeb.rotation.x += chaosbloomWeb.sound * 0.01;
        chaosbloomWeb.rotation.y += chaosbloomWeb.vibration * 0.01;
    }
    controls.update();
    renderer.render(scene, camera);
}
animate();

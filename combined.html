<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Combined Visuals - Grokox Theory</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <header>
        <h1>Combined Visuals</h1>
    </header>
    <main>
        <canvas id="combinedCanvas"></canvas>
        <div class="controls">
            <button onclick="update()">Update</button>
            <div id="binary-module" class="module">
                <h3>Binary</h3>
                <label>Size (1-50): <input type="number" id="binarySize" value="5" min="1" max="50" onchange="update()"></label>
                <label>Color: <input type="color" id="binaryColor" value="#0000FF" onchange="update()"></label>
            </div>
            <div id="quantspark-module" class="module">
                <h3>QuantSpark</h3>
                <label>Count (1-50): <input type="number" id="quantsparkCount" value="10" min="1" max="50" onchange="update()"></label>
                <label>Solid Color: <input type="color" id="quantsparkSolidColor" value="#4B0082" onchange="update()"></label>
            </div>
            <div id="chaosbloom-module" class="module">
                <h3>ChaosBloom</h3>
                <label>Points (1-1000): <input type="number" id="chaosbloomPoints" value="300" min="1" max="1000" onchange="update()"></label>
                <label>Color: <input type="color" id="chaosbloomColor" value="#FF00FF" onchange="update()"></label>
            </div>
        </div>
    </main>
    <footer>
        <p>Â© 2025 Shaggyuk316 - Grokox Theory Project - Powered by xAI</p>
    </footer>
    <script defer>
        console.log('Script start');
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded');
            const canvas = document.getElementById('combinedCanvas');
            if (!canvas) throw new Error('Canvas not found');

            const width = canvas.parentElement.clientWidth * 0.7;
            canvas.style.width = `${width}px`;
            canvas.style.height = '600px';

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / 600, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas });
            renderer.setSize(width, 600);
            scene.background = new THREE.Color(0xffffff);
            camera.position.z = 10;

            let cubes = [], flares = [], points = null;

            function disposeObject(obj) {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            }

            function update() {
                console.log('Updating...');
                // Clear scene but keep references intact
                scene.children.forEach(obj => {
                    scene.remove(obj);
                    disposeObject(obj);
                });

                // Binary Cubes
                const size = parseInt(document.getElementById('binarySize').value) || 5;
                const color = document.getElementById('binaryColor').value || '#0000FF';
                cubes = []; // Reset array but repopulate
                for (let i = 0; i < size; i++) {
                    const geo = new THREE.BoxGeometry(1, 1, 1);
                    const mat = new THREE.MeshBasicMaterial({ color: color });
                    const cube = new THREE.Mesh(geo, mat);
                    cube.position.set(i * 2 - (size - 1), -5, 0);
                    cubes.push(cube);
                    scene.add(cube);
                }
                console.log('Cubes updated:', cubes.length);

                // QuantSpark Flares
                const count = parseInt(document.getElementById('quantsparkCount').value) || 10;
                const solidColor = document.getElementById('quantsparkSolidColor').value || '#4B0082';
                flares = [];
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.5, 16, 16);
                    const mat = new THREE.MeshBasicMaterial({ color: solidColor });
                    const flare = new THREE.Mesh(geo, mat);
                    flare.position.set(Math.random() * 10 - 5, 0, Math.random() * 10 - 5);
                    flares.push(flare);
                    scene.add(flare);
                }
                console.log('Flares updated:', flares.length);

                // ChaosBloom Points
                const pointsCount = parseInt(document.getElementById('chaosbloomPoints').value) || 300;
                const pointColor = document.getElementById('chaosbloomColor').value || '#FF00FF';
                if (points) {
                    scene.remove(points);
                    disposeObject(points);
                }
                const geo = new THREE.BufferGeometry();
                const vertices = new Float32Array(pointsCount * 3);
                const colors = new Float32Array(pointsCount * 3);
                for (let i = 0; i < pointsCount; i++) {
                    const idx = i * 3;
                    vertices[idx] = Math.random() * 10 - 5;
                    vertices[idx + 1] = Math.random() * 10 + 5;
                    vertices[idx + 2] = Math.random() * 10 - 5;
                    const color = new THREE.Color(pointColor);
                    colors[idx] = color.r;
                    colors[idx + 1] = color.g;
                    colors[idx + 2] = color.b;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({ size: 0.1, vertexColors: true });
                points = new THREE.Points(geo, mat);
                scene.add(points);
                console.log('Points updated:', pointsCount);
            }

            function animate() {
                requestAnimationFrame(animate);
                try {
                    cubes.forEach(cube => {
                        cube.rotation.x += 0.01;
                        cube.rotation.y += 0.01;
                    });
                    flares.forEach(flare => {
                        flare.rotation.x += 0.02;
                        flare.position.y += Math.sin(Date.now() * 0.001) * 0.1;
                    });
                    if (points) {
                        const positions = points.geometry.attributes.position.array;
                        for (let i = 1; i < positions.length; i += 3) {
                            positions[i] -= 0.01;
                            if (positions[i] < 2) positions[i] = 12;
                        }
                        points.geometry.attributes.position.needsUpdate = true;
                    }
                    renderer.render(scene, camera);
                    console.log('Animating');
                } catch (e) {
                    console.error('Animation failed:', e);
                }
            }

            console.log('Canvas width:', width);
            update();
            animate();
        });
    </script>
</body>
</html>

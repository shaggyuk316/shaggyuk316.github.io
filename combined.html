<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Combined Visuals - Grokox Theory</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <header>
        <h1>Combined Visuals</h1>
    </header>
    <div class="container left">
        <canvas id="combinedCanvas"></canvas>
    </div>
    <div class="container right">
        <button onclick="update()">Update</button>
        <div id="binary-module" class="module">
            <h2>Binary</h2>
            <label>Size (1-50): <input type="number" id="binarySize" value="5" min="1" max="50" onchange="update()"></label>
            <label>Color: <input type="color" id="binaryColor" value="#0000FF" onchange="update()"></label>
        </div>
        <div id="quantspark-module" class="module">
            <h2>QuantSpark</h2>
            <label>Count (1-50): <input type="number" id="quantsparkCount" value="10" min="1" max="50" onchange="update()"></label>
            <label>Solid Color: <input type="color" id="quantsparkSolidColor" value="#4B0082" onchange="update()"></label>
        </div>
        <div id="chaosbloom-module" class="module">
            <h2>ChaosBloom</h2>
            <label>Points (1-1000): <input type="number" id="chaosbloomPoints" value="300" min="1" max="1000" onchange="update()"></label>
            <label>Color: <input type="color" id="chaosbloomColor" value="#FF00FF" onchange="update()"></label>
        </div>
    </div>
    <footer>
        <p>Â© 2025 Shaggyuk316 - Grokox Theory Project - Powered by xAI</p>
    </footer>
    <script defer>
        console.log('Script start');
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded');
            const canvas = document.getElementById('combinedCanvas');
            if (!canvas) throw new Error('Canvas not found');

            const width = canvas.parentElement.clientWidth;
            const height = 600;
            canvas.width = width;
            canvas.height = height;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas });
            renderer.setSize(width, height);
            scene.background = new THREE.Color(0x000000);
            camera.position.z = 10;

            // Persistent objects
            const cubes = [];
            const flares = [];
            let points = null;

            function disposeObject(obj) {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            }

            function update() {
                console.log('Updating...');
                const newSize = parseInt(document.getElementById('binarySize').value) || 5;
                const newColor = document.getElementById('binaryColor').value || '#0000FF';
                const newCount = parseInt(document.getElementById('quantsparkCount').value) || 10;
                const newSolidColor = document.getElementById('quantsparkSolidColor').value || '#4B0082';
                const newPointsCount = parseInt(document.getElementById('chaosbloomPoints').value) || 300;
                const newPointColor = document.getElementById('chaosbloomColor').value || '#FF00FF';

                // Update Cubes
                while (cubes.length > newSize) {
                    const cube = cubes.pop();
                    scene.remove(cube);
                    disposeObject(cube);
                }
                while (cubes.length < newSize) {
                    const geo = new THREE.BoxGeometry(1, 1, 1);
                    const mat = new THREE.MeshBasicMaterial({ color: newColor });
                    const cube = new THREE.Mesh(geo, mat);
                    cubes.push(cube);
                    scene.add(cube);
                }
                cubes.forEach((cube, i) => {
                    cube.position.set(i * 2 - (newSize - 1), -5, 0);
                    if (cube.material.color.getHexString() !== newColor.slice(1)) {
                        cube.material.color.set(newColor);
                    }
                });
                console.log('Cubes:', cubes.length);

                // Update Flares
                while (flares.length > newCount) {
                    const flare = flares.pop();
                    scene.remove(flare);
                    disposeObject(flare);
                }
                while (flares.length < newCount) {
                    const geo = new THREE.SphereGeometry(0.5, 16, 16);
                    const mat = new THREE.MeshBasicMaterial({ color: newSolidColor });
                    const flare = new THREE.Mesh(geo, mat);
                    flares.push(flare);
                    scene.add(flare);
                }
                flares.forEach((flare, i) => {
                    flare.position.set(Math.random() * 10 - 5, 0, Math.random() * 10 - 5);
                    if (flare.material.color.getHexString() !== newSolidColor.slice(1)) {
                        flare.material.color.set(newSolidColor);
                    }
                });
                console.log('Flares:', flares.length);

                // Update Points
                if (!points || points.geometry.attributes.position.count !== newPointsCount || points.material.color?.getHexString() !== newPointColor.slice(1)) {
                    if (points) {
                        scene.remove(points);
                        disposeObject(points);
                    }
                    const geo = new THREE.BufferGeometry();
                    const vertices = new Float32Array(newPointsCount * 3);
                    const colors = new Float32Array(newPointsCount * 3);
                    for (let i = 0; i < newPointsCount; i++) {
                        const idx = i * 3;
                        vertices[idx] = Math.random() * 10 - 5;
                        vertices[idx + 1] = Math.random() * 10 + 5;
                        vertices[idx + 2] = Math.random() * 10 - 5;
                        const color = new THREE.Color(newPointColor);
                        colors[idx] = color.r;
                        colors[idx + 1] = color.g;
                        colors[idx + 2] = color.b;
                    }
                    geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    points = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.1, vertexColors: true }));
                    scene.add(points);
                    console.log('Points:', newPointsCount);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                try {
                    cubes.forEach(cube => {
                        cube.rotation.x += 0.01;
                        cube.rotation.y += 0.01;
                    });
                    flares.forEach(flare => {
                        flare.rotation.x += 0.02;
                        flare.position.y += Math.sin(Date.now() * 0.001) * 0.1;
                    });
                    if (points) {
                        const positions = points.geometry.attributes.position.array;
                        for (let i = 1; i < positions.length; i += 3) {
                            positions[i] -= 0.01;
                            if (positions[i] < 2) positions[i] = 12;
                        }
                        points.geometry.attributes.position.needsUpdate = true;
                    }
                    renderer.render(scene, camera);
                    console.log('Animating');
                } catch (e) {
                    console.error('Animation failed:', e);
                }
            }

            console.log('Canvas width:', width);
            update();
            animate();
        });
    </script>
</body>
</html>

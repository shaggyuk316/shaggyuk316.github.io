<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Combined Visuals - Grokox Theory</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <h1>Combined Visuals</h1>
    <p>All phases in one view—Grokox Theory chaos.</p>
    <nav>
        <a href="index.html">Home</a> | <a href="visuals.html">Visuals</a> | <a href="quantumibarial.html">Quantumibarial</a> | <a href="combined.html">Combined</a>
    </nav>
    <button onclick="updateAll()">Update Variables</button>

    <div class="visual-section">
        <canvas id="combinedCanvas" style="height: 600px; width: 100%;"></canvas>
        <div class="controls">
            <h3>Binary</h3>
            <label>Size (1-50): <input type="number" id="binarySize" value="5" min="1" max="50" onchange="updateAll()"></label>
            <label>Color: <input type="color" id="binaryColor" value="#0000FF" onchange="updateAll()"></label>
            <label style="color: #FF4500;">Density: <input type="checkbox" id="binaryDensityToggle" checked onchange="updateAll()"> <input type="range" id="binaryDensity" min="0" max="1" step="0.1" value="0.2" onchange="updateAll()"></label>
            <label style="color: #1E90FF;">Sound: <input type="checkbox" id="binarySoundToggle" onchange="updateAll()"> <input type="range" id="binarySound" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Vibration: <input type="checkbox" id="binaryVibrationToggle" onchange="updateAll()"> <input type="range" id="binaryVibration" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Positive Charge: <input type="checkbox" id="binaryPositiveChargeToggle" onchange="updateAll()"> <input type="range" id="binaryPositiveCharge" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Negative Charge: <input type="checkbox" id="binaryNegativeChargeToggle" onchange="updateAll()"> <input type="range" id="binaryNegativeCharge" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>

            <h3>QuantSpark</h3>
            <label>Count (1-50): <input type="number" id="quantsparkCount" value="10" min="1" max="50" onchange="updateAll()"></label>
            <label>Solid Color: <input type="color" id="quantsparkSolidColor" value="#4B0082" onchange="updateAll()"></label>
            <label>Gas Color: <input type="color" id="quantsparkGasColor" value="#FF0000" onchange="updateAll()"></label>
            <label>Magnetic: <input type="checkbox" id="quantsparkMagneticToggle" onchange="updateAll()"> <input type="range" id="quantsparkMagnetic" min="0" max="1" step="0.1" value="0.1" onchange="updateAll()"></label>
            <label style="color: #FF4500;">Density: <input type="checkbox" id="quantsparkDensityToggle" checked onchange="updateAll()"> <input type="range" id="quantsparkDensity" min="0" max="1" step="0.1" value="0.2" onchange="updateAll()"></label>
            <label style="color: #1E90FF;">Sound: <input type="checkbox" id="quantsparkSoundToggle" onchange="updateAll()"> <input type="range" id="quantsparkSound" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Vibration: <input type="checkbox" id="quantsparkVibrationToggle" onchange="updateAll()"> <input type="range" id="quantsparkVibration" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Positive Charge: <input type="checkbox" id="quantsparkPositiveChargeToggle" onchange="updateAll()"> <input type="range" id="quantsparkPositiveCharge" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Negative Charge: <input type="checkbox" id="quantsparkNegativeChargeToggle" onchange="updateAll()"> <input type="range" id="quantsparkNegativeCharge" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>

            <h3>ChaosBloom</h3>
            <label>Points (1-1000): <input type="number" id="chaosbloomPoints" value="300" min="1" max="1000" onchange="updateAll()"></label>
            <label>Color 1: <input type="color" id="chaosbloomColor1" value="#0000FF" onchange="updateAll()"></label>
            <label>Color 2: <input type="color" id="chaosbloomColor2" value="#FF0000" onchange="updateAll()"></label>
            <label>Gravity: <input type="checkbox" id="chaosbloomGravityToggle" onchange="updateAll()"> <input type="range" id="chaosbloomGravity" min="0" max="0.1" step="0.01" value="0.01" onchange="updateAll()"></label>
            <label style="color: #FF4500;">Density: <input type="checkbox" id="chaosbloomDensityToggle" checked onchange="updateAll()"> <input type="range" id="chaosbloomDensity" min="0" max="1" step="0.1" value="0.2" onchange="updateAll()"></label>
            <label style="color: #1E90FF;">Sound: <input type="checkbox" id="chaosbloomSoundToggle" onchange="updateAll()"> <input type="range" id="chaosbloomSound" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Vibration: <input type="checkbox" id="chaosbloomVibrationToggle" onchange="updateAll()"> <input type="range" id="chaosbloomVibration" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Positive Charge: <input type="checkbox" id="chaosbloomPositiveChargeToggle" onchange="updateAll()"> <input type="range" id="chaosbloomPositiveCharge" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
            <label>Negative Charge: <input type="checkbox" id="chaosbloomNegativeChargeToggle" onchange="updateAll()"> <input type="range" id="chaosbloomNegativeCharge" min="0" max="1" step="0.1" value="0.5" onchange="updateAll()"></label>
        </div>
    </div>

    <footer>
        <p>© 2025 Shaggyuk316 - Grokox Theory Project - Powered by xAI</p>
    </footer>

    <script>
        const OrbitControls = (function() {
            /* [Your OrbitControls code from script.js—omitted for brevity] */
            return OrbitControls;
        })();

        function initScene(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas '${canvasId}' not found`);
                return null;
            }
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / 600, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas });
            renderer.setSize(canvas.clientWidth, 600);
            camera.position.z = 30;
            const controls = new OrbitControls(camera, renderer.domElement);
            return { scene, camera, renderer, controls };
        }

        const combined = initScene('combinedCanvas');
        let binaryLattice = [], quantsparkFlares = [], chaosbloomWeb;

        function updateBinaryPhase() {
            const size = parseInt(document.getElementById('binarySize').value) || 5;
            const color = document.getElementById('binaryColor').value || '#0000FF';
            const soundToggle = document.getElementById('binarySoundToggle').checked;
            const soundAmplitude = soundToggle ? parseFloat(document.getElementById('binarySound').value) || 0.5 : 0;
            const densityToggle = document.getElementById('binaryDensityToggle').checked;
            const densityVariation = densityToggle ? parseFloat(document.getElementById('binaryDensity').value) || 0.2 : 0;
            const vibrationToggle = document.getElementById('binaryVibrationToggle').checked;
            const vibrationScale = vibrationToggle ? parseFloat(document.getElementById('binaryVibration').value) || 0.5 : 0;
            const positiveChargeToggle = document.getElementById('binaryPositiveChargeToggle').checked;
            const positiveCharge = positiveChargeToggle ? parseFloat(document.getElementById('binaryPositiveCharge').value) || 0.5 : 0;
            const negativeChargeToggle = document.getElementById('binaryNegativeChargeToggle').checked;
            const negativeCharge = negativeChargeToggle ? parseFloat(document.getElementById('binaryNegativeCharge').value) || 0.5 : 0;
            const baseDensity = 0.1;
            const k_v = 1e-50;
            const k_q = 1e-50;
            const f_s = 1e95;
            const netCharge = positiveCharge - negativeCharge;
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            binaryLattice = [];
            for (let x = -size / 2; x <= size / 2; x += 0.5) {
                for (let y = -size / 2; y <= size / 2; y += 0.5) {
                    const r = Math.sqrt(x * x + y * y);
                    const density = baseDensity + densityVariation * Math.exp(-r * r / 4);
                    const material = new THREE.MeshBasicMaterial({ color: color });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(x, y - 10, 0); // Lowered to separate
                    sphere.soundOffset = Math.sin(2 * Math.PI * (x + y));
                    sphere.density = density;
                    sphere.vibration = k_v * soundAmplitude * f_s * Math.sqrt(density) * vibrationScale;
                    sphere.charge = k_q * netCharge;
                    binaryLattice.push(sphere);
                    combined.scene.add(sphere);
                }
            }
            binaryLattice.soundAmplitude = soundAmplitude;
        }

        function updateQuantsparkPhase() {
            const count = parseInt(document.getElementById('quantsparkCount').value) || 10;
            const solidColor = document.getElementById('quantsparkSolidColor').value || '#4B0082';
            const gasColor = document.getElementById('quantsparkGasColor').value || '#FF0000';
            const magneticToggle = document.getElementById('quantsparkMagneticToggle').checked;
            const magneticStrength = magneticToggle ? parseFloat(document.getElementById('quantsparkMagnetic').value) || 0.1 : 0;
            const soundToggle = document.getElementById('quantsparkSoundToggle').checked;
            const soundAmplitude = soundToggle ? parseFloat(document.getElementById('quantsparkSound').value) || 0.5 : 0;
            const densityToggle = document.getElementById('quantsparkDensityToggle').checked;
            const densityVariation = densityToggle ? parseFloat(document.getElementById('quantsparkDensity').value) || 0.2 : 0;
            const vibrationToggle = document.getElementById('quantsparkVibrationToggle').checked;
            const vibrationScale = vibrationToggle ? parseFloat(document.getElementById('quantsparkVibration').value) || 0.5 : 0;
            const positiveChargeToggle = document.getElementById('quantsparkPositiveChargeToggle').checked;
            const positiveCharge = positiveChargeToggle ? parseFloat(document.getElementById('quantsparkPositiveCharge').value) || 0.5 : 0;
            const negativeChargeToggle = document.getElementById('quantsparkNegativeChargeToggle').checked;
            const negativeCharge = negativeChargeToggle ? parseFloat(document.getElementById('quantsparkNegativeCharge').value) || 0.5 : 0;
            const baseDensity = 0.1;
            const k_v = 1e-50;
            const k_q = 1e-50;
            const f_s = 1e95;
            const netCharge = positiveCharge - negativeCharge;
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            quantsparkFlares = [];
            for (let i = 0; i < count; i++) {
                const solidMaterial = new THREE.MeshBasicMaterial({ color: solidColor });
                const gasMaterial = new THREE.MeshBasicMaterial({ color: gasColor });
                const solid = new THREE.Mesh(geometry, solidMaterial);
                const gas = new THREE.Mesh(geometry, gasMaterial);
                solid.position.set(Math.random() * 4 - 2, Math.random() * 4 - 2, Math.random() * 4 - 2);
                gas.position.set(Math.random() * 4 - 2, Math.random() * 4 - 2, Math.random() * 4 - 2);
                solid.velocity = new THREE.Vector3(Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05);
                gas.velocity = new THREE.Vector3(Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05);
                const r = solid.position.length();
                const density = baseDensity + densityVariation * Math.sin(r);
                solid.density = density;
                gas.density = density;
                solid.vibration = k_v * soundAmplitude * f_s * Math.sqrt(density) * vibrationScale;
                gas.vibration = solid.vibration;
                solid.charge = k_q * netCharge;
                gas.charge = k_q * netCharge;
                quantsparkFlares.push({ solid, gas });
                combined.scene.add(solid, gas);
            }
            quantsparkFlares.magneticStrength = magneticStrength;
            quantsparkFlares.soundAmplitude = soundAmplitude;
        }

        function updateChaosbloomPhase() {
            const points = parseInt(document.getElementById('chaosbloomPoints').value) || 300;
            const color1 = document.getElementById('chaosbloomColor1').value || '#0000FF';
            const color2 = document.getElementById('chaosbloomColor2').value || '#FF0000';
            const gravityToggle = document.getElementById('chaosbloomGravityToggle').checked;
            const gravityStrength = gravityToggle ? parseFloat(document.getElementById('chaosbloomGravity').value) || 0.01 : 0;
            const soundToggle = document.getElementById('chaosbloomSoundToggle').checked;
            const soundAmplitude = soundToggle ? parseFloat(document.getElementById('chaosbloomSound').value) || 0.5 : 0;
            const densityToggle = document.getElementById('chaosbloomDensityToggle').checked;
            const densityVariation = densityToggle ? parseFloat(document.getElementById('chaosbloomDensity').value) || 0.2 : 0;
            const vibrationToggle = document.getElementById('chaosbloomVibrationToggle').checked;
            const vibrationScale = vibrationToggle ? parseFloat(document.getElementById('chaosbloomVibration').value) || 0.5 : 0;
            const positiveChargeToggle = document.getElementById('chaosbloomPositiveChargeToggle').checked;
            const positiveCharge = positiveChargeToggle ? parseFloat(document.getElementById('chaosbloomPositiveCharge').value) || 0.5 : 0;
            const negativeChargeToggle = document.getElementById('chaosbloomNegativeChargeToggle').checked;
            const negativeCharge = negativeChargeToggle ? parseFloat(document.getElementById('chaosbloomNegativeCharge').value) || 0.5 : 0;
            const baseDensity = 0.1;
            const k_v = 1e-50;
            const k_q = 1e-50;
            const f_s = 1e95;
            const netCharge = positiveCharge - negativeCharge;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const positions = [];
            for (let i = 0; i < points; i++) {
                const x = (Math.random() - 0.5) * 10;
                const y = (Math.random() - 0.5) * 10 + 10; // Raised to separate
                const z = (Math.random() - 0.5) * 10;
                const r = Math.sqrt(x * x + y * y + z * z);
                const density = baseDensity + densityVariation * r;
                vertices.push(x, y, z);
                const color = Math.random() < 0.5 ? new THREE.Color(color1) : new THREE.Color(color2);
                colors.push(color.r, color.g, color.b);
                const pos = new THREE.Vector3(x, y, z);
                pos.density = density;
                pos.vibration = k_v * soundAmplitude * f_s * Math.sqrt(density) * vibrationScale;
                pos.charge = k_q * netCharge;
                positions.push(pos);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ size: 0.1, vertexColors: true });
            chaosbloomWeb = new THREE.Points(geometry, material);
            chaosbloomWeb.positions = positions;
            chaosbloomWeb.gravityStrength = gravityStrength;
            chaosbloomWeb.soundAmplitude = soundAmplitude;
            combined.scene.add(chaelbloomWeb);
        }

        function updateAll() {
            if (!combined) {
                console.error('Combined scene not initialized');
                return;
            }
            combined.scene.clear();
            updateBinaryPhase();
            updateQuantsparkPhase();
            updateChaosbloomPhase();
        }

        if (combined) {
            updateAll();
        } else {
            console.error('Combined scene failed to initialize');
        }

        function animate() {
            requestAnimationFrame(animate);
            binaryLattice.forEach(sphere => {
                sphere.scale.set(1 + Math.sin(Date.now() * 0.001) * sphere.soundAmplitude, 1, 1);
            });
            quantsparkFlares.forEach(flare => {
                const soundEnergy = flare.soundAmplitude * Math.sin(Date.now() * 0.001) * flare.solid.density;
                const solidForce = flare.solid.velocity.clone().multiplyScalar(0.01 + soundEnergy);
                const gasForce = flare.gas.velocity.clone().multiplyScalar(0.01 + soundEnergy);
                flare.solid.velocity.add(solidForce);
                flare.gas.velocity.add(gasForce);
                flare.solid.position.add(flare.solid.velocity);
                flare.gas.position.add(flare.gas.velocity);
                flare.solid.position.clamp(new THREE.Vector3(-4, -4, -4), new THREE.Vector3(4, 4, 4));
                flare.gas.position.clamp(new THREE.Vector3(-4, -4, -4), new THREE.Vector3(4, 4, 4));
                flare.solid.scale.set(1 + Math.sin(Date.now() * 0.005 + flare.soundAmplitude), 1, 1);
                flare.gas.scale.set(1 + Math.sin(Date.now() * 0.007 + flare.soundAmplitude), 1, 1);
            });
            if (chaelbloomWeb) {
                const positions = chaosbloomWeb.positions;
                const posArray = chaosbloomWeb.geometry.attributes.position.array;
                const soundEnergy = chaosbloomWeb.soundAmplitude * Math.sin(Date.now() * 0.001);
                for (let i = 0; i < positions.length; i++) {
                    const p1 = positions[i];
                    p1.y += soundEnergy * 0.01; // Sound influences vertical motion
                    p1.clamp(new THREE.Vector3(-10, 0, -10), new THREE.Vector3(10, 20, 10));
                    posArray[i * 3] = p1.x;
                    posArray[i * 3 + 1] = p1.y;
                    posArray[i * 3 + 2] = p1.z;
                }
                chaosbloomWeb.geometry.attributes.position.needsUpdate = true;
                chaosbloomWeb.rotation.x += 0.01;
                chaosbloomWeb.rotation.y += 0.01;
            }
            if (combined) {
                combined.controls.update();
                combined.renderer.render(combined.scene, combined.camera);
            }
        }
        animate();
    </script>
</body>
</html>

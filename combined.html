<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Combined Visuals - Grokox Theory</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <header>
        <h1>Combined Visuals</h1>
    </header>
    <main>
        <canvas id="combinedCanvas"></canvas>
        <div class="controls">
            <button onclick="update()">Update</button>
            <div id="binary-module" class="module">
                <h3>Binary</h3>
                <label>Size (1-50): <input type="number" id="binarySize" value="5" min="1" max="50" onchange="update()"></label>
                <label>Color: <input type="color" id="binaryColor" value="#0000FF" onchange="update()"></label>
            </div>
            <div id="quantspark-module" class="module">
                <h3>QuantSpark</h3>
                <label>Count (1-50): <input type="number" id="quantsparkCount" value="10" min="1" max="50" onchange="update()"></label>
                <label>Solid Color: <input type="color" id="quantsparkSolidColor" value="#4B0082" onchange="update()"></label>
            </div>
            <div id="chaosbloom-module" class="module">
                <h3>ChaosBloom</h3>
                <label>Points (1-1000): <input type="number" id="chaosbloomPoints" value="300" min="1" max="1000" onchange="update()"></label>
                <label>Color: <input type="color" id="chaosbloomColor" value="#FF00FF" onchange="update()"></label>
            </div>
        </div>
    </main>
    <footer>
        <p>Â© 2025 Shaggyuk316 - Grokox Theory Project - Powered by xAI</p>
    </footer>
    <script defer>
        console.log('Script start');
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded');
            const canvas = document.getElementById('combinedCanvas');
            if (!canvas) throw new Error('Canvas not found');

            const width = canvas.parentElement.clientWidth * 0.7;
            canvas.style.width = `${width}px`;
            canvas.style.height = '600px';

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / 600, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas });
            renderer.setSize(width, 600);
            scene.background = new THREE.Color(0xffffff);
            camera.position.z = 10;

            let cubes = [], flares = [], points = null;

            function disposeObject(obj) {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            }

            function update() {
                console.log('Updating...');
                const newSize = parseInt(document.getElementById('binarySize').value) || 5;
                const newColor = document.getElementById('binaryColor').value || '#0000FF';
                const newCount = parseInt(document.getElementById('quantsparkCount').value) || 10;
                const newSolidColor = document.getElementById('quantsparkSolidColor').value || '#4B0082';
                const newPointsCount = parseInt(document.getElementById('chaosbloomPoints').value) || 300;
                const newPointColor = document.getElementById('chaosbloomColor').value || '#FF00FF';

                // Update Binary Cubes
                if (cubes.length !== newSize || cubes[0]?.material.color.getHexString() !== newColor.slice(1)) {
                    scene.children.filter(obj => cubes.includes(obj)).forEach(obj => {
                        scene.remove(obj);
                        disposeObject(obj);
                    });
                    cubes = [];
                    for (let i = 0; i < newSize; i++) {
                        const geo = new THREE.BoxGeometry(1, 1, 1);
                        const mat = new THREE.MeshBasicMaterial({ color: newColor });
                        const cube = new THREE.Mesh(geo, mat);
                        cube.position.set(i * 2 - (newSize - 1), -5, 0);
                        cubes.push(cube);
                        scene.add(cube);
                    }
                    console.log('Cubes updated:', cubes.length);
                }

                // Update QuantSpark Flares
                if (flares.length !== newCount || flares[0]?.material.color.getHexString() !== newSolidColor.slice(1)) {
                    scene.children.filter(obj => flares.includes(obj)).forEach(obj => {
                        scene.remove(obj);
                        disposeObject(obj);
                    });
                    flares = [];
                    for (let i = 0; i < newCount; i++) {
                        const geo = new THREE.SphereGeometry(0.5, 16, 16);
                        const mat = new THREE.MeshBasicMaterial({ color: newSolidColor });
                        const flare = new THREE.Mesh(geo, mat);
                        flare.position.set(Math.random() * 10 - 5, 0, Math.random() * 10 - 5);
                        flares.push(flare);
                        scene.add(flare);
                    }
                    console.log('Flares updated:', flares.length);
                }

                // Update ChaosBloom Points
                if (!points || points.geometry.attributes.position.count !== newPointsCount || points.material.color?.getHexString() !== newPointColor.slice(1)) {
                    if (points) {
                        scene.remove(points);
                        disposeObject(points);
                    }
                    const geo = new THREE.BufferGeometry();
                    const vertices = new Float32Array(newPointsCount * 3);
                    const colors = new Float32Array(newPointsCount * 3);
                    for (let i = 0; i < newPointsCount; i++) {
                        const idx = i * 3;
                        vertices[idx] = Math.random() * 10 - 5;
                        vertices[idx + 1] = Math.random() * 10 + 5;
                        vertices[idx + 2] = Math.random() * 10 - 5;
                        const color = new THREE.Color(newPointColor);
                        colors[idx] = color.r;
                        colors[idx + 1] = color.g;
                        colors[idx + 2] = color.b;
                    }
                    geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const mat = new THREE.PointsMaterial({ size: 0.1, vertexColors: true });
                    points = new THREE.Points(geo, mat);
                    scene.add(points);
                    console.log('Points updated:', newPointsCount);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                try {
                    cubes.forEach(cube => {
                        cube.rotation.x += 0.01;
                        cube.rotation.y += 0.01;
                    });
                    flares.forEach(flare => {
                        flare.rotation.x += 0.02;
                        flare.position.y += Math.sin(Date.now() * 0.001) * 0.1;
                    });
                    if (points) {
                        const positions = points.geometry.attributes.position.array;
                        for (let i = 1; i < positions.length; i += 3) {
                            positions[i] -= 0.01;
                            if (positions[i] < 2) positions[i] = 12;
                        }
                        points.geometry.attributes.position.needsUpdate = true;
                    }
                    renderer.render(scene, camera);
                    console.log('Animating');
                } catch (e) {
                    console.error('Animation failed:', e);
                }
            }

            console.log('Canvas width:', width);
            update();
            animate();
        });
    </script>
</body>
</html>

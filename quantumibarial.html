<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantumibarial - Grokox Theory</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <h1>Quantumibarial Phase</h1>
    <p>Built with Grok 3 by xAI—exploring chaos beyond binary.</p>
    <button onclick="updateAll()">Update Variables</button>

    <div class="visual-section">
        <h2>Binary</h2>
        <canvas id="binaryCanvas" style="height: 400px;"></canvas>
        <div class="controls">
            <label>Size (1-50): <input type="number" id="binarySize" value="5" min="1" max="50" onchange="updateBinary()"></label>
            <label>Color: <input type="color" id="binaryColor" value="#00ff00" onchange="updateBinary()"></label>
            <label>Density: <input type="checkbox" id="binaryDensityToggle" onchange="updateBinary()"> <input type="range" id="binaryDensity" min="0.5" max="5" step="0.1" value="1" onchange="updateBinary()"></label>
        </div>
    </div>

    <div class="visual-section">
        <h2>Quantuminial</h2>
        <canvas id="quantCanvas" style="height: 400px;"></canvas>
        <div class="controls">
            <label>Radius (0.5-10): <input type="range" id="quantRadius" min="0.5" max="10" step="0.1" value="1" onchange="updateQuant()"></label>
            <label>Energy: <input type="checkbox" id="quantEnergyToggle" onchange="updateQuant()"> <input type="range" id="quantEnergy" min="0" max="100" value="10" onchange="updateQuant()"></label>
            <label>Color: <input type="color" id="quantColor" value="#007bff" onchange="updateQuant()"></label>
            <label>Density: <input type="checkbox" id="quantDensityToggle" onchange="updateQuant()"> <input type="range" id="quantDensity" min="0.5" max="5" step="0.1" value="1" onchange="updateQuant()"></label>
        </div>
    </div>

    <div class="visual-section">
        <h2>Quantumibarial</h2>
        <canvas id="quantumibarialCanvas" style="height: 400px;"></canvas>
        <div class="controls">
            <label>Nodes (1-100): <input type="number" id="nodeCount" value="3" min="1" max="100" onchange="updateQuantumibarial()"></label>
            <label>Color: <input type="color" id="quantibColor" value="#ff00ff" onchange="updateQuantumibarial()"></label>
            <label>Density: <input type="checkbox" id="densityToggle" onchange="updateQuantumibarial()"> <input type="range" id="density" min="0.5" max="5" step="0.1" value="1" onchange="updateQuantumibarial()"></label>
            <label>Energy: <input type="checkbox" id="energyToggle" onchange="updateQuantumibarial()"> <input type="range" id="energy" min="0" max="100" value="10" onchange="updateQuantumibarial()"></label>
            <label>Dark Energy: <input type="checkbox" id="darkEnergyToggle" onchange="updateQuantumibarial()"> <input type="range" id="darkEnergy" min="0" max="1" step="0.1" value="0.5" onchange="updateQuantumibarial()"></label>
        </div>
    </div>

    <script>
        // OrbitControls (copied from your script.js—same as before, omitted here for brevity)
        const OrbitControls = (function() {
            /* [Your OrbitControls code here—identical to script.js] */
            return OrbitControls;
        })();

        function initScene(canvasId) {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            const camera = new THREE.PerspectiveCamera(75, 1200 / 400, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById(canvasId) });
            renderer.setSize(1200, 400);
            camera.position.z = 20;
            const controls = new OrbitControls(camera, renderer.domElement);
            return { scene, camera, renderer, controls };
        }

        const binary = initScene('binaryCanvas');
        const quant = initScene('quantCanvas');
        const quantib = initScene('quantumibarialCanvas');
        let binaryCubes = [], quantSphere, quantibNetwork = [];

        function updateBinary() {
            binary.scene.clear();
            binaryCubes = [];
            const size = parseInt(document.getElementById('binarySize').value) || 5;
            const color = document.getElementById('binaryColor').value || '#00ff00';
            const densityToggle = document.getElementById('binaryDensityToggle').checked;
            const density = densityToggle ? parseFloat(document.getElementById('binaryDensity').value) || 1 : 1;
            const geo = new THREE.BoxGeometry(density, density, density);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for (let i = 0; i < size; i++) {
                const cube = new THREE.Mesh(geo, mat);
                cube.position.set(i * 2 - (size - 1), 0, 0);
                binaryCubes.push(cube);
                binary.scene.add(cube);
            }
        }

        function updateQuant() {
            quant.scene.clear();
            const radius = parseFloat(document.getElementById('quantRadius').value) || 1;
            const energyToggle = document.getElementById('quantEnergyToggle').checked;
            const energy = energyToggle ? parseFloat(document.getElementById('quantEnergy').value) || 10 : 10;
            const color = document.getElementById('quantColor').value || '#007bff';
            const densityToggle = document.getElementById('quantDensityToggle').checked;
            const density = densityToggle ? parseFloat(document.getElementById('quantDensity').value) || 1 : 1;
            const geo = new THREE.SphereGeometry(radius * density, 32, 32);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            quantSphere = new THREE.Mesh(geo, mat);
            quantSphere.energy = energy;
            quant.scene.add(quantSphere);
        }

        function updateQuantumibarial() {
            quantib.scene.clear();
            quantibNetwork = [];
            const nodeCount = parseInt(document.getElementById('nodeCount').value) || 3;
            const color = document.getElementById('quantibColor').value || '#ff00ff';
            const densityToggle = document.getElementById('densityToggle').checked;
            const density = densityToggle ? parseFloat(document.getElementById('density').value) || 1 : 1;
            const energyToggle = document.getElementById('energyToggle').checked;
            const energy = energyToggle ? parseFloat(document.getElementById('energy').value) || 10 : 10;
            const darkEnergyToggle = document.getElementById('darkEnergyToggle').checked;
            const darkEnergy = darkEnergyToggle ? parseFloat(document.getElementById('darkEnergy').value) || 0.5 : 0.5;
            const geo = new THREE.SphereGeometry(0.5 * density, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for (let i = 0; i < nodeCount; i++) {
                const sphere = new THREE.Mesh(geo, mat);
                sphere.position.set(i * 2 - (nodeCount - 1), 0, 0);
                sphere.energy = energy * darkEnergy;
                quantibNetwork.push(sphere);
                quantib.scene.add(sphere);
            }
        }

        function updateAll() {
            updateBinary();
            updateQuant();
            updateQuantumibarial();
        }
        updateAll();

        function animate() {
            requestAnimationFrame(animate);
            if (quantSphere) {
                quantSphere.rotation.x += 0.05;
                quantSphere.rotation.y += 0.05;
            }
            quantibNetwork.forEach(s => {
                s.position.y += Math.sin(Date.now() * 0.001) * 0.1 * (s.energy / 10);
            });
            binary.controls.update();
            quant.controls.update();
            quantib.controls.update();
            binary.renderer.render(binary.scene, binary.camera);
            quant.renderer.render(quant.scene, quant.camera);
            quantib.renderer.render(quantib.scene, quantib.camera);
        }
        animate();
    </script>
</body>
</html>

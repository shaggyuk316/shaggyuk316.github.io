<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantumibarial - Grokox Theory</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        h1 { text-align: center; margin: 20px 0 10px; font-size: 2em; }
        p { text-align: center; margin: 0 0 20px; font-size: 1.1em; }
        nav { text-align: center; margin: 10px 0; }
        nav a { margin: 0 10px; text-decoration: none; color: #007BFF; }
        nav a:hover { text-decoration: underline; }
        #quantumCanvas { height: 600px; width: 100%; display: block; }
        button { display: block; margin: 10px auto; padding: 5px 10px; font-size: 1em; }
        footer { text-align: center; margin-top: 20px; font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>Quantumibarial</h1>
    <p>Exploring chaos at the quantum scale—Grokox Theory dynamics.</p>
    <nav>
        <a href="index.html">Home</a> | <a href="visuals.html">Visuals</a> | <a href="quantumibarial.html">Quantumibarial</a> | <a href="combined.html">Combined</a>
    </nav>
    <button onclick="toggleAudio()">Toggle Audio Input</button>

    <div class="visual-section">
        <canvas id="quantumCanvas"></canvas>
    </div>

    <footer>
        <p>© 2025 Shaggyuk316 - Grokox Theory Project - Powered by xAI</p>
    </footer>

    <script>
        // Core Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 600, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('quantumCanvas') });
        renderer.setSize(window.innerWidth, 600);
        scene.background = new THREE.Color(0xffffff); // White background
        camera.position.set(0, 0, 10);
        camera.lookAt(0, 0, 0);

        // Animation Objects
        let binaryCubes = [];
        let quantSparkSphere = null;
        let chaosBloomNetwork = [];

        // Audio Setup
        let audioContext, analyser, dataArray, audioStream;
        let audioActive = false;

        async function initAudio() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                const source = audioContext.createMediaStreamSource(audioStream);
                source.connect(analyser);
                audioActive = true;
                console.log('Audio initialized');
            } catch (err) {
                console.error('Audio init failed:', err);
            }
        }

        function toggleAudio() {
            if (!audioActive) {
                initAudio();
            } else {
                audioStream.getTracks().forEach(track => track.stop());
                audioContext.close();
                audioActive = false;
                console.log('Audio stopped');
            }
        }

        function getFrequencyData() {
            if (!analyser) return { low: 0, mid: 0, high: 0 };
            analyser.getByteFrequencyData(dataArray);
            const low = dataArray.slice(0, 32).reduce((a, b) => a + b, 0) / 32 / 255; // 0-500 Hz
            const mid = dataArray.slice(32, 96).reduce((a, b) => a + b, 0) / 64 / 255; // 500-2000 Hz
            const high = dataArray.slice(96).reduce((a, b) => a + b, 0) / 32 / 255; // 2000+ Hz
            return { low, mid, high };
        }

        // Initialize Scene Objects
        function initScene() {
            scene.children = [];
            binaryCubes = [];
            quantSparkSphere = null;
            chaosBloomNetwork = [];

            // Binary: Static cubes (bottom)
            const binaryGeo = new THREE.BoxGeometry(1, 1, 1);
            const binaryMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            for (let i = 0; i < 5; i++) {
                const cube = new THREE.Mesh(binaryGeo, binaryMat);
                cube.position.set(i * 2 - 4, -5, 0);
                binaryCubes.push(cube);
                scene.add(cube);
            }

            // QuantSpark: Thrashing sphere (middle)
            const quantGeo = new THREE.SphereGeometry(1, 32, 32);
            const quantMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
            quantSparkSphere = new THREE.Mesh(quantGeo, quantMat);
            quantSparkSphere.position.set(0, 0, 0);
            scene.add(quantSparkSphere);

            // ChaosBloom: Networked spheres (top)
            const chaosGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const chaosMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            for (let i = 0; i < 3; i++) {
                const sphere = new THREE.Mesh(chaosGeo, chaosMat);
                sphere.position.set(i * 2 - 2, 5, 0);
                chaosBloomNetwork.push(sphere);
                scene.add(sphere);
            }
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            const freq = getFrequencyData();

            // Binary Cubes: Scale with low frequencies
            binaryCubes.forEach(cube => {
                cube.scale.setScalar(1 + freq.low);
                cube.rotation.y += 0.01 * freq.low;
            });

            // QuantSpark Sphere: Thrash with mid frequencies
            if (quantSparkSphere) {
                quantSparkSphere.rotation.x += 0.05 * (1 + freq.mid);
                quantSparkSphere.rotation.y += 0.05 * (1 + freq.mid);
            }

            // ChaosBloom Network: Pulse with high frequencies
            chaosBloomNetwork.forEach(sphere => {
                sphere.position.y = 5 + Math.sin(Date.now() * 0.001) * 0.5 * (1 + freq.high);
                sphere.scale.setScalar(1 + freq.high * 0.5);
            });

            renderer.render(scene, camera);
        }

        // Start Everything
        initScene();
        animate();
    </script>
</body>
</html>
